Text
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/****************************************************************
* AUTOR:	DANILO BARBOSA RODRIGUES			*
* DATA:		22.03.2007					*
* ARQUIVO:	RF3383.PRC					*
* NOME:		SANPP_RF_VALORIZACAO_CALCULOS_SALDOS            *
* DESCRICAO:	PROCEDURE PARA CALCULO EM LOTE PARA RENDA FIXA.	*
*****************************************************************
* ALTERACAO:	DANILO B. RODRIGUES				*
* DATA:		18.06.2007					*
* MOTIVO:	MUDANCA NO CALCULO DO IR/IOF PARA CLIENTES	*
*****************************************************************
* ALTERACAO:	LIGIA MUTO					*
* DATA:		21/11/2008					*
* MOTIVO:	TRATAMENTO PARA CURVA DE NEGOCIAÇÃO             *
****************************************************************/

-- IF EXISTS (SELECT * FROM SYSOBJECTS WHERE ID = OBJECT_ID('SANPP_RF_VALORIZACAO_CALCULOS_SALDOS'))
-- 	DROP PROCEDURE SANPP_RF_VALORIZACAO_CALCULOS_SALDOS
-- GO

CREATE PROCEDURE DBO.SANPP_RF_VALORIZACAO_CALCULOS_SALDOS
	(
	@DT_ICAL		DATETIME,
	@DT_FNAL		DATETIME,
	@GERAR_LOG_BATCH	CHAR(01) = 'N',		-- UTILIZADO NA VALORIZACAO BATCH, PARA GERAR O LOG DE PROGRESSO E ERROS
	@DT_PROCESSO		DATETIME = NULL		-- UTILIZADO NA VALORIZACAO BATCH, PARA GERAR O LOG DE PROGRESSO E ERROS
	)

AS
BEGIN	-- RF3383.PRC

	-- SE NAO EXISTIR NENHUM REGISTRO, SAI DA PROCEDURE


	IF NOT EXISTS(SELECT TOP 1 RF_CARACTERISTICA FROM #OPRC_LOTE)
	BEGIN
		RETURN
	END




	CREATE TABLE #TMP_DATA_MINIMA(
		RF_CARACTERISTICA	CHAR(20),
		DT_MINIMA		DATETIME
	)

	CREATE TABLE #TMP_MOVIMENCACOES(
		RF_CARACTERISTICA	CHAR(22),
		RFS_DATA		DATETIME,
		ATV_AP			CHAR(01),
		RFS_PRINCIPAL		FLOAT,
		RFS_QTDE		FLOAT,
		RFS_QTDE_C		FLOAT,
		RFS_FIN_C		FLOAT,
		RFS_QTDE_V		FLOAT,
		RFS_FIN_V		FLOAT,
		PU_CURVA		FLOAT,
		FIN_TRUNCA		CHAR(01),
		RFS_IOF			FLOAT,
		IOF_C			FLOAT,
		IOF_V			FLOAT
	)


	CREATE TABLE #TMP_CALC_PROVISAO(
		RF_CARACTERISTICA	VARCHAR(20),
		PFPJ_APELIDO_EMPRESA	CHAR(15),
		EH_FUNDO		CHAR(01),
		RFS_DATA		DATETIME,
		RFS_DATA_ANTERIOR	DATETIME,
		QTDE_SALDO		FLOAT,
		RFS_PU_UTEIS		FLOAT,
		RFS_PU_CORRIDOS		FLOAT,
		RFS_PU_MERCADO		FLOAT,
		PROVISAO_DIF		FLOAT,
		PROVISAO		FLOAT,
		PROVISAO_ANT		FLOAT,
		FDO_MES_BALANCO		CHAR(02),
		DT_BALANCO		DATETIME,
		VIRA_SEMESTRE		CHAR(01),
		PROVANT_ANTERIOR	FLOAT,
		PROVDIF_ANTERIOR	FLOAT,
		PROV_ANTERIOR		FLOAT,
		IC_CALCULADO		CHAR(01)
	)


	CREATE TABLE #TMP_PROVISAO_TRANSF(
		RF_CARACTERISTICA	CHAR(22),
		RFS_DATA		DATETIME,
		RFS_PU_UTEIS		FLOAT,
		RFS_PU_CORRIDOS		FLOAT,
		RFS_PU_MERCADO		FLOAT,
		RFS_PROVISAO		FLOAT,
		RFS_PROVISAO_DIF	FLOAT
	)

	CREATE TABLE #TMP_TRANSF_VENDA(
		RF_CARACTERISTICA	CHAR(22),
		RFS_DATA		DATETIME,
		QTDE_V			FLOAT
	)


	CREATE TABLE #TMP_CALC_FATOR_ACUD(
		RF_CARACTERISTICA	VARCHAR(20),
		RFS_DATA		DATETIME,
		RFS_DATA_ANTERIOR	DATETIME,
		PU_UTEIS		FLOAT,
		PU_UTEIS_ANTERIOR	FLOAT,
		PU_MERC			FLOAT,
		PU_MERC_ANTERIOR	FLOAT,
		V_FATR_ACUD_UTES_ANT	FLOAT,
		V_FATR_ACUD_MERC_ANT	FLOAT,
		V_FATR_ACUD_UTES	FLOAT,
		V_FATR_ACUD_MERC	FLOAT,
		IC_CALCULADO		CHAR(01),
		PU_PARTIDA		FLOAT
	)



	CREATE TABLE #TMP_IR_IOFR(
		RF_CARACTERISTICA	CHAR(20),
		RFS_DATA		DATETIME,
		DT_APLICACAO		DATETIME,
		QTD_DIAS		INT,
		IOF_FCALC		CHAR(03),
		IR_FCALC		CHAR(03),
		QTDE_SALDO		FLOAT,
		PU_APLICACAO		FLOAT,
		VALOR_APLICACAO		FLOAT,
		PU_CURVA		FLOAT,
		VALOR_CURVA		FLOAT,
		IOF_ALIQUOTA		FLOAT,
		CIP_TABPROG		CHAR(05),
		PU_RENDIMENTO		FLOAT,
		RENDIMENTO_BRUTO	FLOAT,
		DIAS_LIMITE		INT,
		IOF			FLOAT,
		PERC_IOF		FLOAT,
		REND_PERC		FLOAT,
		VALOR_IOF		FLOAT,
		ISENTO_IR		CHAR(01),
		FATOR_IR_INICIAL	FLOAT,
		ATV_RENDA		CHAR(01),
		EMPRESA			CHAR(15),
		RENDIMENTO_TOTAL	FLOAT,
		FCALC_APLICACAO		CHAR(03),
		FCALC_POSICAO		CHAR(03),
		VALOR_IR		FLOAT
	)


	CREATE TABLE #TMP_ALIQUOTAS(
		ATV_RENDA		CHAR(01),
		RFS_DATA		DATETIME,
		DT_APLICACAO		DATETIME,
		DT_INI			DATETIME,
		DT_FIM			DATETIME,
		DT_MP206		DATETIME,
		V_ALQT			FLOAT,
		QTD_DIAS		INT
	)


CREATE TABLE #IOF_RENDA_TRIBUTACAO
	(
	ATV_RENDA CHAR(01) NOT NULL ,
	IOF_DATA_INI DATETIME NOT NULL ,
	IOF_DATA_FIM DATETIME NOT NULL ,
	IOF_ALIQUOTA FLOAT NOT NULL ,
	IOF_FLAG CHAR (01) NULL ,
	CIP_TABPROG char(5) 
	)

-- CREATE TABLE [IOF_RENDA_TRIBUTACAO] (
-- 	[ATV_RENDA] [CHAR01] NOT NULL ,
-- 	[IOF_DATA_INI] [smalldatetime] NOT NULL ,
-- 	[IOF_DATA_FIM] [smalldatetime] NOT NULL ,
-- 	[IOF_ALIQUOTA] [float] NOT NULL ,
-- 	[IOF_FLAG] [CHAR01] NULL ,
-- 	[CIP_TABPROG] [char] (5) COLLATE SQL_Latin1_General_CP1_CI_AS NULL 
-- ) ON [PRIMARY]
-- GO




	INSERT INTO #IOF_RENDA_TRIBUTACAO VALUES ('X', '1999-01-25', '1999-06-16', 0.38, '', '')
	INSERT INTO #IOF_RENDA_TRIBUTACAO VALUES ('X', '1999-06-17', '2079-01-25', 0.0, '', '')
	INSERT INTO #IOF_RENDA_TRIBUTACAO VALUES ('X', '1999-06-17', '2079-01-25', 0.38, 'A', 264)  
	INSERT INTO #IOF_RENDA_TRIBUTACAO VALUES ('X', '1999-08-01', '2079-01-25', 1.0, 'R', 264)


	-- PREENCHE TEMPORARIA COM A MENOR DATA DO PERIODO DE CADA CARACTERISTICA
	INSERT INTO #TMP_DATA_MINIMA
	SELECT
		RF_CARACTERISTICA,
		MIN(RFS_DATA)
	FROM
		#OPRC_LOTE
	GROUP BY
		RF_CARACTERISTICA

	CREATE INDEX IDX_CARAC ON #TMP_DATA_MINIMA (RF_CARACTERISTICA)


	DECLARE
		@RF_CARACTERISTICA	CHAR(22),
		@RFS_DATA		DATETIME,
		@ATV_AP			CHAR(01),
		@RFS_PRINCIPAL		FLOAT,
		@RFS_QTDE		FLOAT,
		@RFS_QTDE_C		FLOAT,
		@RFS_FIN_C		FLOAT,
		@RFS_QTDE_V		FLOAT,
		@RFS_FIN_V		FLOAT,
		@PROPORCIONAL_MOV	FLOAT,
		@ULT_CARACTERISTICA	CHAR(22),
		@ULT_PRINCIPAL		FLOAT,
		@PU_CURVA		FLOAT,
		@FIN_CURVA		FLOAT,
		@FIN_TRUNCA		CHAR(01),
		@RFS_RESULTADO		FLOAT,
		@RFS_IOF		FLOAT,
		@IOF_C			FLOAT,
		@IOF_V			FLOAT,
		@ULT_IOF		FLOAT,
		@IOF_PROPORCIONAL	FLOAT,
		@QTD_PROPORCIONAL_MOV	FLOAT,
		@ANO			INT,
		@MES_BALANCO		INT,
		@DIA_ATUAL		INT,
		@DT_AUX			CHAR(10),
		@RFS_PU_UTEIS		FLOAT,
		@RFS_PU_CORRIDOS	FLOAT,
		@RFS_PU_MERCADO		FLOAT,
		@RFS_PROVISAO		FLOAT,
		@RFS_PROVISAO_DIF	FLOAT,
		@DT_ATUAL		DATETIME,
		@QTD_REG_INSERIR	INT,
		@QTD_TOTAL_MOV		FLOAT,
		@QTD_MOV		FLOAT,
		@JUROS_MOV		FLOAT,
		@CORRECAO_MOV		FLOAT,
		@PRINCIPAL_MOV		FLOAT,
		@JUROS_BX		FLOAT,
		@CORRECAO_BX		FLOAT,
		@PRINCIPAL_BX		FLOAT,
		@DATAHORA		CHAR(23),
		@PRINCIPAL_BASE		FLOAT,
		@SPID			INT,
		@VDT_CORTE_IOF		DATETIME,
		@VDT_RET_CORTE_IOF	DATETIME,
		@VIT_COUNT		INT


	DECLARE @CARAC CHAR(20) 

	-- BUSCA CODIGO DA CONEXAO PRINCIPAL


	SELECT	@SPID = SPID
	FROM
		#TMP_CONEXAO


	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END


	IF @GERAR_LOG_BATCH = 'S'
	BEGIN
		INSERT INTO SANT1984_RF_CONTROLE_VALORIZACAO (DT_B, SGL_T_RG, SPID, DT_H_ATC, TXT_DESC_EVE)
		VALUES (@DT_PROCESSO, 'MSG', @SPID, GETDATE(), 'Calculando outras colunas na RF_SALDOS (LOTE)')
	END


	-- ***************INICIO DO CALCULO DOS CAMPOS: RFS_PRINCIPAL, RFS_RESULTADO E OUTROS AUXILIARES*****************

	-- CALCULO DO RFS_PRINCIPAL (CRIA TEMPORARIA COM TODAS AS MOVIMENTACOES DO PERIORO DE CADA OPERACAO)

	EXEC ('
		INSERT INTO #TMP_MOVIMENCACOES
		SELECT
			A.RF_CARACTERISTICA, A.RFS_DATA, B.ATV_AP, A.RFS_PRINCIPAL, A.RFS_QTDE, A.RFS_QTDE_C, A.RFS_FIN_C, A.RFS_QTDE_V, A.RFS_FIN_V
			, V_PU_CTBL AS PU_CURVA, B.FIN_TRUNCA, A.RFS_IOF, A.IOF_C, A.IOF_V
		FROM
			#OPRC_LOTE A
		JOIN	#OPERACOES_GERAL B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE
			(A.RFS_QTDE_C <> 0.0 OR A.RFS_QTDE_V <> 0.0) ')


	-- CURSOR PARA CALCULAR O RFS_PRINCIPAL E RFS_RESULTADO PARA AS CARACTERISTICAS, CONSIDERANDO SOMENTE OS DIAS QUE TIVEREM MOVIMENTACAO, POIS A PROC DE CALCULO DOS PUs JA PREENCHEU TODOS OS REGISTROS COM O RFS_PRINCIPAL ANTERIOR

	DECLARE curRFS_PRINCIPAL CURSOR LOCAL READ_ONLY
	FOR
	SELECT
		RF_CARACTERISTICA, RFS_DATA, ATV_AP, RFS_PRINCIPAL, RFS_QTDE, RFS_QTDE_C, RFS_FIN_C, RFS_QTDE_V, RFS_FIN_V, PU_CURVA, FIN_TRUNCA, RFS_IOF, IOF_C, IOF_V
	FROM
		#TMP_MOVIMENCACOES
	ORDER BY
		RF_CARACTERISTICA, RFS_DATA

	open curRFS_PRINCIPAL


	-- INICIALIZACAO DO LOOP

	SELECT
		@ULT_CARACTERISTICA	=	''

	WHILE 1 = 1
	BEGIN
		FETCH NEXT FROM curRFS_PRINCIPAL
		INTO	@RF_CARACTERISTICA,
			@RFS_DATA,
			@ATV_AP,
			@RFS_PRINCIPAL,
			@RFS_QTDE,
			@RFS_QTDE_C,
			@RFS_FIN_C,
			@RFS_QTDE_V,
			@RFS_FIN_V,
			@PU_CURVA,
			@FIN_TRUNCA,
			@RFS_IOF,
			@IOF_C,
			@IOF_V

		IF @@FETCH_STATUS <> 0
			BREAK


		-- CONTROLE DE ITERACAO PARA OPERACAO NOVA

		IF @RF_CARACTERISTICA <> @ULT_CARACTERISTICA
		BEGIN
			SELECT	@ULT_PRINCIPAL	=	@RFS_PRINCIPAL,
				@ULT_IOF	=	@RFS_IOF
		END


		-- INICIA COM O VALOR ANTERIOR DO IOF

		SELECT	@RFS_IOF = @ULT_IOF

INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 383'


		-- REGRAS DIFERENCIADAS PARA ATIVOS E PASSIVOS

		IF @ATV_AP = 'A'
			BEGIN

			-- CALCULANDO A MOVIMENTACAO PROPORCIONAL AO PRINCIPAL E RESULTADO

			SELECT
				@PROPORCIONAL_MOV = CONVERT(MONEY, (@ULT_PRINCIPAL + @RFS_FIN_C) * (@RFS_QTDE_V / (ABS(@RFS_QTDE) + @RFS_QTDE_C))),
				@RFS_PRINCIPAL = (@ULT_PRINCIPAL + @RFS_FIN_C),
				@FIN_CURVA = @PU_CURVA * @RFS_QTDE_V,
				@RFS_RESULTADO = @RFS_FIN_V,
				@QTD_PROPORCIONAL_MOV = @RFS_QTDE_V / (ABS(@RFS_QTDE) + @RFS_QTDE_C)

			-- TRATAMENTO PARA RFS_IOF
			IF @RFS_QTDE_C <> 0.0
				BEGIN
				SELECT	@RFS_IOF = @RFS_IOF + @IOF_C
				END
			IF @RFS_QTDE_V <> 0.0
				BEGIN
				IF @RFS_QTDE = @RFS_QTDE_V	-- VENDA FINAL
					SELECT	@RFS_IOF = 0.0
				ELSE
					BEGIN
					SELECT	@IOF_PROPORCIONAL = @RFS_IOF * (@RFS_QTDE_V / (@RFS_QTDE+@RFS_QTDE_C))
					EXEC TRUNC @IOF_PROPORCIONAL, 2, @IOF_PROPORCIONAL OUTPUT
					SELECT	@RFS_IOF = @RFS_IOF - @IOF_PROPORCIONAL
					END
				END

			END
		ELSE
			BEGIN

			-- CALCULANDO A MOVIMENTACAO PROPORCIONAL AO PRINCIPAL E RESULTADO

			SELECT
				@PROPORCIONAL_MOV = CONVERT(MONEY, (@ULT_PRINCIPAL + @RFS_FIN_V) * (@RFS_QTDE_C / (ABS(@RFS_QTDE) + @RFS_QTDE_V))),
				@RFS_PRINCIPAL = (@ULT_PRINCIPAL + @RFS_FIN_V),
				@FIN_CURVA = @PU_CURVA * @RFS_QTDE_C,
				@RFS_RESULTADO = @RFS_FIN_C,
				@QTD_PROPORCIONAL_MOV = @RFS_QTDE_C / (ABS(@RFS_QTDE) + @RFS_QTDE_V)

			-- TRATAMENTO PARA RFS_IOF
			IF @RFS_QTDE_V <> 0.0
				BEGIN
				SELECT	@RFS_IOF = @RFS_IOF + @IOF_V
				END
			IF @RFS_QTDE_C <> 0.0
				BEGIN
				IF @RFS_QTDE = @RFS_QTDE_C	-- VENDA FINAL
					SELECT	@RFS_IOF = 0.0
				ELSE
					BEGIN
					SELECT	@IOF_PROPORCIONAL = @RFS_IOF * (@RFS_QTDE_C / (@RFS_QTDE+@RFS_QTDE_V))
					EXEC TRUNC @IOF_PROPORCIONAL, 2, @IOF_PROPORCIONAL OUTPUT
					SELECT	@RFS_IOF = @RFS_IOF - @IOF_PROPORCIONAL
					END
				END
			END


		-- TRUNCA OU ARREDONDA

INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 457'


		IF @FIN_TRUNCA = 'S'
			BEGIN
				EXEC TRUNC @FIN_CURVA, 2, @FIN_CURVA OUTPUT
			END
		ELSE
			BEGIN
				SELECT
					@FIN_CURVA = ROUND(@FIN_CURVA, 2)
			END


		-- CALCULA RESULTADO

		SELECT
			@RFS_RESULTADO = CONVERT(MONEY, @RFS_RESULTADO - @FIN_CURVA)


		-- TRUNCA A MOVIMENTACAO PROPORCIONAL AO PRINCIPAL
		EXEC TRUNC @PROPORCIONAL_MOV, 2, @PROPORCIONAL_MOV OUTPUT


		-- TRUNCA O RESULTADO
		EXEC TRUNC @RFS_RESULTADO, 2, @RFS_RESULTADO OUTPUT


		-- ATUALIZA A PARTIR DA DATA ATUAL
		SELECT @RFS_PRINCIPAL = CONVERT(MONEY, @RFS_PRINCIPAL - @PROPORCIONAL_MOV)

		UPDATE	#OPRC_LOTE
		SET	RFS_PRINCIPAL	=	@RFS_PRINCIPAL,
			RFS_RESULTADO	=	CASE
							WHEN RFS_DATA = @RFS_DATA THEN
								@RFS_RESULTADO
							ELSE
								0.0
						END,
			RFS_IOF		=	@RFS_IOF,
			FINANCEIRO_CURVA=	CASE
							WHEN RFS_DATA = @RFS_DATA THEN
								@FIN_CURVA
							ELSE
								0.0
						END,
			PROPORCIONAL_MOV=	CASE
							WHEN RFS_DATA = @RFS_DATA THEN
								@PROPORCIONAL_MOV
							ELSE
								0.0
						END,
			QTD_PROPORCIONAL_MOV=	CASE
							WHEN RFS_DATA = @RFS_DATA THEN
								@QTD_PROPORCIONAL_MOV
							ELSE
								0.0
						END
		WHERE
			RF_CARACTERISTICA	=	@RF_CARACTERISTICA
		AND	RFS_DATA		>=	@RFS_DATA


		-- VALORES QUE SERAO UTILIZADOS NA PROXIMA ITERACAO
		SELECT
			@ULT_CARACTERISTICA	=	@RF_CARACTERISTICA,
			@ULT_PRINCIPAL		=	@RFS_PRINCIPAL,
			@ULT_IOF		=	@RFS_IOF
	END

	CLOSE curRFS_PRINCIPAL
	DEALLOCATE curRFS_PRINCIPAL


	-- CALCULA O PRINCIPAL_ABERTURA

	UPDATE	A
	SET	PRINCIPAL_ABERTURA = B.RFS_PRINCIPAL
	FROM
		#OPRC_LOTE A
	JOIN	#OPRC_LOTE B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	B.RFS_DATA = DATEADD(DAY, -1, A.RFS_DATA)



	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END



	-- CALCULA O JUROS E CORRECAO

	EXEC ('
		UPDATE	A
		SET	RENDIMENTO	=	CASE
							WHEN B.FIN_TRUNCA = ''S'' THEN	-- TRUNCAR O FINANCEIRO NA CURVA
								DBO.SANFS_RF_TRUNCAR(CONVERT(MONEY, DBO.SANFS_RF_TRUNCAR(A.V_PU_CTBL * ABS(A.RFS_QTDE), 2) - A.PRINCIPAL_ABERTURA), 2)
							ELSE
								DBO.SANFS_RF_TRUNCAR(CONVERT(MONEY, ROUND(A.V_PU_CTBL * ABS(A.RFS_QTDE), 2) - A.PRINCIPAL_ABERTURA), 2)
						END
		FROM
			#OPRC_LOTE A
		JOIN	#OPERACOES_GERAL B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	')

	EXEC ('
		UPDATE	A
		SET	RFS_CORRECAO	=	CASE
							WHEN B.EH_FUNDO = ''S'' OR B.IDX_PRE = ''S'' THEN
								0.0
							ELSE
								A.RENDIMENTO
						END
		FROM
			#OPRC_LOTE A
		JOIN	#OPERACOES_GERAL B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	')

	UPDATE	A
	SET	RFS_JUROS	=	CONVERT(MONEY, A.RENDIMENTO - A.RFS_CORRECAO)
	FROM
		#OPRC_LOTE A


	-- CALCULA O RFS_APROPRIAR_ANT (JUROS SOBRE O SALDO FECHAMENTO)

	UPDATE	A
	SET	RFS_APROPRIAR_ANT	=	RFS_JUROS - DBO.SANFS_RF_TRUNCAR(CONVERT(MONEY, FINANCEIRO_CURVA - PROPORCIONAL_MOV - DBO.SANFS_RF_TRUNCAR(CONVERT(MONEY, RFS_CORRECAO * QTD_PROPORCIONAL_MOV), 2)), 2),
		JUROS_BASE		=	DBO.SANFS_RF_TRUNCAR(CONVERT(MONEY, FINANCEIRO_CURVA - PROPORCIONAL_MOV - DBO.SANFS_RF_TRUNCAR(CONVERT(MONEY, RFS_CORRECAO * QTD_PROPORCIONAL_MOV), 2)), 2)
	FROM
		#OPRC_LOTE A


	-- CALCULA O JUROS ANTERIOR E A CORRECAO ANTERIOR

	UPDATE	A
	SET	RFS_JUROS_ANT		=	B.RFS_APROPRIAR_ANT,
		RFS_CORRECAO_ANT	=	B.RFS_CORRECAO
	FROM
		#OPRC_LOTE A
	JOIN	#OPRC_LOTE B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	B.RFS_DATA = DATEADD(DAY, -1, A.RFS_DATA)


	-- CALCULANDO JUROS, CORRECAO E PRINCIPAL PROPORCIONAIS AS MOVIMENTACOES

	DECLARE curMOVIMENTACAO CURSOR LOCAL READ_ONLY
	FOR
	SELECT	A.RF_CARACTERISTICA, A.RFS_DATA, B.ATV_AP, A.RFS_CORRECAO, A.RFS_QTDE_C, A.RFS_QTDE_V, A.QTD_PROPORCIONAL_MOV, A.JUROS_BASE, A.PROPORCIONAL_MOV
	FROM
		#OPRC_LOTE A
	JOIN	#OPERACOES_GERAL B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	WHERE
		(
			(B.ATV_AP = 'A' AND A.RFS_QTDE_V <> 0.0)
		OR
			(B.ATV_AP = 'P' AND A.RFS_QTDE_C <> 0.0)
		)
	ORDER BY A.RF_CARACTERISTICA, A.RFS_DATA

	-- ABRE CURSOR COM AS MOVIMENTACOES DO PERIODO
	OPEN curMOVIMENTACAO

	WHILE 1=1
	BEGIN
		FETCH NEXT FROM curMOVIMENTACAO
		INTO	@RF_CARACTERISTICA	,
			@RFS_DATA		,
			@ATV_AP			,
			@CORRECAO_MOV		,
			@RFS_QTDE_C		,
			@RFS_QTDE_V		,
			@QTD_PROPORCIONAL_MOV	,
			@JUROS_MOV		,
			@PRINCIPAL_MOV

		IF @@FETCH_STATUS <> 0
			BREAK


		-- PEGA A QUANTIDADE TOTAL DO DIA DE VENDA DE ATIVO OU COMPRA DE PASSIVO

		IF @ATV_AP = 'A'
		BEGIN
			SELECT	@QTD_TOTAL_MOV = @RFS_QTDE_V
		END
		ELSE
		BEGIN
			SELECT	@QTD_TOTAL_MOV = @RFS_QTDE_C
		END

		-- INICIALIZA VARIAVEIS

		SELECT 	@DATAHORA = '',
			@PRINCIPAL_BASE = @PRINCIPAL_MOV,
			@CORRECAO_MOV = DBO.SANFS_RF_TRUNCAR(@CORRECAO_MOV * @QTD_PROPORCIONAL_MOV, 2) -- CORRECAO PROPORCIONAL AO MOVIMENTO DO DIA

		-- PERCORRE CADA MOVIMENTO DO DIA, INDIVIDUALMENTE
		WHILE @QTD_TOTAL_MOV > 0.0
		BEGIN
			SET ROWCOUNT 1

			-- PEGA PROXIMO MOVIMENTO PARA A CARACTERISTICA E DATA ATUAL

			SELECT	@DATAHORA = CONVERT(CHAR(8),RFM_DATA,112) + RFM_HORA + RFM_USUARIO,
				@QTD_MOV = RFM_QTDE
			FROM
				RF_MOVIMENTACAO (nolock)
			WHERE
				RF_CARACTERISTICA = @RF_CARACTERISTICA
			AND	CONVERT(CHAR(8),RFM_DATA,112) + RFM_HORA + RFM_USUARIO > @DATAHORA
			AND	RFM_DT = CASE @ATV_AP WHEN 'A' THEN 'C' ELSE 'A' END
			AND	RFM_DTERMO = @RFS_DATA
			AND	RFM_OK = 'S'
			ORDER BY CONVERT(CHAR(8),RFM_DATA,112) + RFM_HORA + RFM_USUARIO

			SET ROWCOUNT 0


			-- QUANDO FOR O ULTIMO MOVIMENTO, UTILIZA TODO O VALOR RESTANTE



			IF (@QTD_TOTAL_MOV - @QTD_MOV) = 0.0
				SELECT	@CORRECAO_BX = @CORRECAO_MOV,
					@JUROS_BX = @JUROS_MOV,
					@PRINCIPAL_BX = @PRINCIPAL_MOV
			ELSE
			BEGIN
				-- CALCULA OS VALORES PROPORCIONAIS AO MOVIMENTO ATUAL

				SELECT	@CORRECAO_BX = (@CORRECAO_MOV / @QTD_TOTAL_MOV) * (@QTD_MOV),
					@JUROS_BX = (@JUROS_MOV / @QTD_TOTAL_MOV) * (@QTD_MOV),
					@PRINCIPAL_BX = (@PRINCIPAL_MOV / @QTD_TOTAL_MOV) * (@QTD_MOV)   -- (@PRINCIPAL_BASE / @QTD_TOTAL_MOV) * (@QTD_MOV)

					SELECT @CORRECAO_BX = CONVERT(MONEY, @CORRECAO_BX)
					SELECT @JUROS_BX = CONVERT(MONEY, @JUROS_BX)
					SELECT @PRINCIPAL_BX = CONVERT(MONEY, @PRINCIPAL_BX)
					EXEC TRUNC @CORRECAO_BX, 2, @CORRECAO_BX OUTPUT
					EXEC TRUNC @JUROS_BX, 2, @JUROS_BX OUTPUT
					EXEC TRUNC @PRINCIPAL_BX, 2, @PRINCIPAL_BX OUTPUT

				SELECT	@CORRECAO_MOV = @CORRECAO_MOV - @CORRECAO_BX,
					@JUROS_MOV = @JUROS_MOV - @JUROS_BX,
					@PRINCIPAL_MOV = @PRINCIPAL_MOV - @PRINCIPAL_BX


					INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
					  SELECT 
					    USU_DATA_HORA  = GETDATE()
					  , USU_CODIGO     = 'SQL'
					  , STRU_MODULO    = 'RF3383'
					  , SIS_CODIGO     = 'VLZ'
					  , DESC_OPER      = 'LINHA: 718'
					

			END

			-- ATUALIZA A RF_MOVIMENTACAO

			UPDATE	RF_MOVIMENTACAO
			SET	RFM_CORRECAO = ISNULL(@CORRECAO_BX, 0),
				RFM_JUROS = ISNULL(@JUROS_BX, 0),
				RFM_PRINCIPAL = ISNULL(@PRINCIPAL_BX, 0)
			WHERE
				RFM_USUARIO = SUBSTRING(@DATAHORA, 21, 3)
			AND	RFM_HORA    = SUBSTRING(@DATAHORA, 9, 12)
			AND	RFM_DATA = SUBSTRING(@DATAHORA, 1, 8)
			AND	RF_CARACTERISTICA = @RF_CARACTERISTICA


			-- DECREMENTA A QUANTIDADE DO MOVIMENTO ATUAL

			SELECT @QTD_TOTAL_MOV = CONVERT(MONEY, @QTD_TOTAL_MOV - @QTD_MOV)
		END

	END

	CLOSE curMOVIMENTACAO
	DEALLOCATE curMOVIMENTACAO


INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 753'


	-- AJUSTA A CORRECAO ANTERIOR, PARA CASOS EM QUE HOUVE MOVIMENTACAO NO DIA ANTERIOR

	EXEC ('
		UPDATE	A
		SET	RFS_CORRECAO_ANT = A.RFS_CORRECAO_ANT - (SELECT ISNULL(SUM(RFM_CORRECAO),0.0)
								FROM RF_MOVIMENTACAO (nolock)
								WHERE RF_CARACTERISTICA = A.RF_CARACTERISTICA AND RFM_DTERMO = DATEADD(DAY, -1, A.RFS_DATA)
									AND RFM_DT =	CASE C.ATV_AP
												WHEN ''A'' THEN
													''C''
												ELSE
													''A''
											END
									AND RFM_OK = ''S'')
		FROM
			#OPRC_LOTE A
		JOIN	RF_MOVIMENTACAO B (nolock)
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		AND	B.RFM_DTERMO = DATEADD(DAY, -1, A.RFS_DATA)
		JOIN	#OPERACOES_GERAL C
		ON	A.RF_CARACTERISTICA = C.RF_CARACTERISTICA
		WHERE
			A.RFS_CORRECAO <> 0.0
	')


	-- CALCULA JUROS CONTABIL E CORRECAO CONTABIL

	UPDATE	A
	SET	V_JURS_CTBL	=	RFS_JUROS,
		V_CORC_CTBL	=	RFS_CORRECAO,
		V_JURS_CTBL_ANTR=	RFS_JUROS_ANT,
		V_CORC_CTBL_ANTR=	RFS_CORRECAO_ANT
	FROM
		#OPRC_LOTE A


INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 799'


	-- CALCULA JUROS CONTABIL E CORRECAO CONTABIL PARA FUNDOS (UTILIZANDO SEMPRE A CURVA UTEIS, E ZERANDO EM DIAS QUE NAO SAO RESERVA)

	-- LIGIA MUTO - 21/11/2008
	-- INCLUSÃO DESSA CONDIÇÃO NO UPDATE ABAIXO: AND B.CTB_CURVA <> ''N''
	-- PARA CTB_CURVA = 'N' NÃO DEVE UTILIZAR A CURVA ÚTEIS E SIM A CURVA DE NEGOCIAÇÃO

	EXEC ('
		UPDATE	A
		SET	V_JURS_CTBL	=	CASE
							WHEN A.EH_RESERVA = ''S'' THEN
--								DBO.SANFS_RF_TRUNCAR(((ABS(RFS_QTDE) - A.QTD_CTBL) * RFS_PU_UTEIS) - (PRINCIPAL_ABERTURA - A.PRINCIPAL_CTBL), 2)
								DBO.SANFS_RF_TRUNCAR((ABS(RFS_QTDE) * RFS_PU_UTEIS) - PRINCIPAL_ABERTURA, 2)
							ELSE
								0.0
						END,
			V_JURS_CTBL_ANTR=	CASE
							WHEN A.EH_RESERVA = ''S'' THEN
--								DBO.SANFS_RF_TRUNCAR(((ABS(RFS_QTDE) - A.QTD_CTBL) * PU_U_ANTERIOR) - (PRINCIPAL_ABERTURA - A.PRINCIPAL_CTBL), 2)
								DBO.SANFS_RF_TRUNCAR((ABS(RFS_QTDE) * PU_U_ANTERIOR) - PRINCIPAL_ABERTURA, 2)
							ELSE
								0.0
						END
		FROM
			#OPRC_LOTE A
		JOIN	#OPERACOES_GERAL B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE
			B.EH_FUNDO	=	''S''
			AND B.CTB_CURVA <> ''N''
	')



	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END




	-- ***************INICIO DO CALCULO DAS PROVISOES*****************

	-- INSERE NA TEMPORARIA OS CAMPOS NECESSARIOS PARA OS CALCULOS (MELHOR DESEMPENHO, COMPARADO AO CALCULO NA TEMPORARIA ORIGINAL)

	INSERT INTO #TMP_CALC_PROVISAO
	EXEC ('
		SELECT
			A.RF_CARACTERISTICA, A.PFPJ_APELIDO_EMPRESA, A.EH_FUNDO, B.RFS_DATA, B.RFS_DATA_ANTERIOR, ABS(RFS_QTDE + RFS_QTDE_C - RFS_QTDE_V) AS QTDE_SALDO, RFS_PU_UTEIS, RFS_PU_CORRIDOS, RFS_PU_MERCADO
			, 0.0, 0.0, 0.0
			, RIGHT(''00'' + RTRIM(CONVERT(VARCHAR(02), ISNULL(A.FDO_MES_BALANCO, 0))), 2)
			, NULL, ''''
			, B.PROVANT_ANTERIOR, B.PROVDIF_ANTERIOR, B.PROV_ANTERIOR, ''N''
		FROM
			#OPERACOES_GERAL A
		JOIN	#OPRC_LOTE B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE	-- PARA FUNDOS, O CALCULO EH OBRIGATORIO. PARA NAO FUNDOS, SOMENTE SE EXISTIR O EVENTO CONTABIL PARA A POSICAO
			A.EH_FUNDO	=	''S''
		OR	EXISTS(	SELECT TOP 1 REGR_CHAVE
				FROM	REGRA_CONTABIL (nolock)
				WHERE	PFPJ_APELIDO_EMPRESA	=	A.PFPJ_APELIDO_EMPRESA
				AND	ATV_CODIGO		=	A.ATV_CODIGO
				AND	IDX_CODIGO		=	A.IDX_CODIGO
				AND	EVEN_CODIGO		IN	(''450'',''451'')
			)
	')

	-- INDICES PARA MELHORAR DESEMPENHO NOS CRUZAMENTOS

	CREATE INDEX IDX_CARAC_DATA_CALC ON #TMP_CALC_PROVISAO (RF_CARACTERISTICA, RFS_DATA, IC_CALCULADO)
	CREATE INDEX IDX_CALC ON #TMP_CALC_PROVISAO (IC_CALCULADO)


	-- CALCULA A DIFERENCA DIARIA ENTRE AS CURVAS

	UPDATE	#TMP_CALC_PROVISAO
	SET	PROVISAO_DIF	=	CASE
						WHEN EH_FUNDO = 'S' THEN	-- PARA FUNDOS, UTILIZA A CURVA UTEIS
							(QTDE_SALDO * RFS_PU_MERCADO) - (QTDE_SALDO * RFS_PU_UTEIS)
						ELSE
							(QTDE_SALDO * RFS_PU_MERCADO) - (QTDE_SALDO * RFS_PU_CORRIDOS)
					END


	-- AJUSTA O MES DE BALANCO DE FUNDOS, CASO NAO ESTEJA PREENCHIDO

	UPDATE	#TMP_CALC_PROVISAO
	SET	FDO_MES_BALANCO	=	CASE
						WHEN FDO_MES_BALANCO = '00' THEN
							'12'
						ELSE
							FDO_MES_BALANCO
					END
	WHERE
		EH_FUNDO = 'S'


	-- CURSOR PARA CALCULAR O ULTIMO DIA DO MES DE BALANCO (SOMENTE PARA FUNDOS)

	DECLARE curDATA_BALANCO CURSOR LOCAL READ_ONLY
	FOR
	SELECT DISTINCT YEAR(RFS_DATA) AS ANO, FDO_MES_BALANCO
	FROM
		#TMP_CALC_PROVISAO
	WHERE
		EH_FUNDO = 'S'
	AND	FDO_MES_BALANCO = SUBSTRING(CONVERT(CHAR(08), RFS_DATA, 112), 5, 2)

	OPEN curDATA_BALANCO

	WHILE 1 = 1
	BEGIN
		FETCH NEXT FROM curDATA_BALANCO
		INTO	@ANO,
			@MES_BALANCO

		IF @@FETCH_STATUS <> 0
			BREAK

		SELECT	@DIA_ATUAL = 31,
			@DT_AUX = ''

		-- FICA NO LOOP ATE QUE A DATA CALCULADA SEJA VALIDA
		WHILE ISDATE(@DT_AUX) = 0
		BEGIN
			-- STRING NO FORMATO YYYY-MM-DD
			SELECT	@DT_AUX = CONVERT(CHAR(04), @ANO) + '-' + RIGHT('00' + CONVERT(VARCHAR(02), @MES_BALANCO), 2) + '-' + RIGHT('00' + CONVERT(VARCHAR(02), @DIA_ATUAL), 2)
			SELECT	@DIA_ATUAL = @DIA_ATUAL - 1
		END

		-- ATUALIZA A DATA DE BALANCO NOS DIAS CONTIDOS NO MESMO MES DE BALANCO

		UPDATE	#TMP_CALC_PROVISAO
		SET	DT_BALANCO	=	@DT_AUX
		WHERE
			EH_FUNDO	=	'S'
		AND	YEAR(RFS_DATA)	=	@ANO
		AND	FDO_MES_BALANCO =	SUBSTRING(CONVERT(CHAR(08), RFS_DATA, 112), 5, 2)

	END

	CLOSE curDATA_BALANCO
	DEALLOCATE curDATA_BALANCO


	-- MARCA O FLAG DE VIRADA DE SEMESTRE (NAO FUNDOS) OU DATA DE BALANCO (FUNDOS)

	UPDATE	#TMP_CALC_PROVISAO
	SET	VIRA_SEMESTRE	=	CASE
						WHEN EH_FUNDO = 'S' AND SUBSTRING(CONVERT(CHAR(08), RFS_DATA, 112), 5, 4) = SUBSTRING(CONVERT(CHAR(08), DT_BALANCO, 112), 5, 4) THEN
							'S'
						WHEN EH_FUNDO = 'N' AND SUBSTRING(CONVERT(CHAR(08), RFS_DATA, 112), 5, 4) IN ('0630', '1231') THEN
							'S'
						ELSE
							'N'
					END



	-- ATUALIZA PROVISAO ANTERIOR PARA A PRIMEIRA DATA DE TODAS AS OPERACOES

	UPDATE	A
	SET	PROVISAO_ANT	=	CASE
						WHEN RFS_DATA_ANTERIOR = '1900-01-01' THEN
							0.0
						WHEN PROVANT_ANTERIOR = 0.0 AND VIRA_SEMESTRE = 'N' THEN
							PROVANT_ANTERIOR
						WHEN PROVANT_ANTERIOR = 0.0 AND VIRA_SEMESTRE = 'S' AND EH_FUNDO = 'N' THEN
							(QTDE_SALDO * RFS_PU_MERCADO) - (QTDE_SALDO * RFS_PU_CORRIDOS)
						WHEN PROVANT_ANTERIOR = 0.0 AND VIRA_SEMESTRE = 'S' AND EH_FUNDO = 'S' THEN
							(QTDE_SALDO * RFS_PU_MERCADO) - (QTDE_SALDO * RFS_PU_UTEIS)
						WHEN ABS(PROVANT_ANTERIOR) > 0.0 AND VIRA_SEMESTRE = 'S' AND EH_FUNDO = 'N' THEN
							((QTDE_SALDO * RFS_PU_MERCADO) - (QTDE_SALDO * RFS_PU_CORRIDOS)) - PROVANT_ANTERIOR
						WHEN ABS(PROVANT_ANTERIOR) > 0.0 AND VIRA_SEMESTRE = 'S' AND EH_FUNDO = 'S' THEN
							((QTDE_SALDO * RFS_PU_MERCADO) - (QTDE_SALDO * RFS_PU_UTEIS)) - PROVANT_ANTERIOR
						WHEN ABS(PROVANT_ANTERIOR) > 0.0 AND VIRA_SEMESTRE = 'N' THEN
							CASE
								WHEN ((PROVISAO_DIF > 0 AND PROVDIF_ANTERIOR < 0) OR (PROVISAO_DIF < 0 AND PROVDIF_ANTERIOR > 0)) AND ABS(PROVDIF_ANTERIOR)>ABS(PROV_ANTERIOR) THEN
									PROVANT_ANTERIOR + ABS(PROVDIF_ANTERIOR - PROV_ANTERIOR)
								WHEN ((PROVISAO_DIF >= 0 AND PROVDIF_ANTERIOR >= 0) OR (PROVISAO_DIF <= 0 AND PROVDIF_ANTERIOR <= 0)) AND ABS(PROVISAO_DIF)>ABS(PROVDIF_ANTERIOR) THEN
									PROVANT_ANTERIOR
								WHEN ((PROVISAO_DIF >= 0 AND PROVDIF_ANTERIOR >= 0) OR (PROVISAO_DIF <= 0 AND PROVDIF_ANTERIOR <= 0)) AND ABS(PROVISAO_DIF)<ABS(PROVDIF_ANTERIOR) AND ABS(PROVISAO_DIF - PROVDIF_ANTERIOR)>ABS(PROV_ANTERIOR) THEN
									PROVANT_ANTERIOR + (PROVISAO_DIF - PROVDIF_ANTERIOR + PROV_ANTERIOR)
								WHEN ((PROVISAO_DIF >= 0 AND PROVDIF_ANTERIOR >= 0) OR (PROVISAO_DIF <= 0 AND PROVDIF_ANTERIOR <= 0)) AND ABS(PROVISAO_DIF)<ABS(PROVDIF_ANTERIOR) AND NOT ABS(PROVISAO_DIF - PROVDIF_ANTERIOR)>ABS(PROV_ANTERIOR) THEN
									PROVANT_ANTERIOR
								ELSE
									0.0	--NAO ENTRA EM NENHUMA ALTERNATIVA
							END
					END
	FROM
		#TMP_CALC_PROVISAO	A
	JOIN	#TMP_DATA_MINIMA	B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.DT_MINIMA


	-- ATUALIZA A PROVISAO PARA A PRIMEIRA DATA DE TODAS AS OPERACOES. MARCA O FLAG PARA NAO SEREM INCLUIDOS NAS PROXIMAS ATUALIZACOES MAIS ABAIXO

	UPDATE	A
	SET	IC_CALCULADO	=	'S',
		PROVISAO	=	CASE
						WHEN RFS_DATA_ANTERIOR = '1900-01-01' THEN
							PROVISAO_DIF
						WHEN EH_FUNDO = 'S' THEN
							(QTDE_SALDO * RFS_PU_MERCADO) - ((QTDE_SALDO * RFS_PU_UTEIS) + PROVISAO_ANT)
						ELSE
							(QTDE_SALDO * RFS_PU_MERCADO) - ((QTDE_SALDO * RFS_PU_CORRIDOS) - PROVISAO_ANT)
					END
	FROM
		#TMP_CALC_PROVISAO	A
	JOIN	#TMP_DATA_MINIMA	B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.DT_MINIMA


	-- FICA NO LOOP ATE QUE NAO HAJA MAIS REGISTROS A SEREM ATUALIZADOS, NA PRATICA, ELE RODA A QUANTIDADE DE DIAS DO PERIODO MENOS UM, POIS O PRIMEIRO DIA FOI CALCULADO LOGO ACIMA


	SELECT @CARAC = MIN (RF_CARACTERISTICA) FROM #TMP_CALC_PROVISAO 
--	WHILE EXISTS(SELECT TOP 1 RF_CARACTERISTICA FROM #TMP_CALC_PROVISAO WHERE IC_CALCULADO = 'N')
	WHILE @CARAC IS NOT NULL
	BEGIN
		-- ATUALIZA PROVISAO ANTERIOR

		UPDATE	A
		SET	PROVISAO_ANT	=	CASE
							WHEN B.PROVISAO_ANT = 0.0 AND A.VIRA_SEMESTRE = 'N' THEN
								B.PROVISAO_ANT
							WHEN B.PROVISAO_ANT = 0.0 AND A.VIRA_SEMESTRE = 'S' AND A.EH_FUNDO = 'N' THEN
								(A.QTDE_SALDO * A.RFS_PU_MERCADO) - (A.QTDE_SALDO * A.RFS_PU_CORRIDOS)
							WHEN B.PROVISAO_ANT = 0.0 AND A.VIRA_SEMESTRE = 'S' AND A.EH_FUNDO = 'S' THEN
								(A.QTDE_SALDO * A.RFS_PU_MERCADO) - (A.QTDE_SALDO * A.RFS_PU_UTEIS)
							WHEN ABS(B.PROVISAO_ANT) > 0.0 AND A.VIRA_SEMESTRE = 'S' AND A.EH_FUNDO = 'N' THEN
								((A.QTDE_SALDO * A.RFS_PU_MERCADO) - (A.QTDE_SALDO * A.RFS_PU_CORRIDOS)) - B.PROVISAO_ANT
							WHEN ABS(B.PROVISAO_ANT) > 0.0 AND A.VIRA_SEMESTRE = 'S' AND A.EH_FUNDO = 'S' THEN
								((A.QTDE_SALDO * A.RFS_PU_MERCADO) - (A.QTDE_SALDO * A.RFS_PU_UTEIS)) - B.PROVISAO_ANT
							WHEN ABS(B.PROVISAO_ANT) > 0.0 AND A.VIRA_SEMESTRE = 'N' THEN
								CASE
									WHEN ((A.PROVISAO_DIF > 0 AND B.PROVISAO_DIF < 0) OR (A.PROVISAO_DIF < 0 AND B.PROVISAO_DIF > 0)) AND ABS(B.PROVISAO_DIF)>ABS(B.PROVISAO) THEN
										B.PROVISAO_ANT + ABS(B.PROVISAO_DIF - B.PROVISAO)
									WHEN ((A.PROVISAO_DIF >= 0 AND B.PROVISAO_DIF >= 0) OR (A.PROVISAO_DIF <= 0 AND B.PROVISAO_DIF <= 0)) AND ABS(A.PROVISAO_DIF)>ABS(B.PROVISAO_DIF) THEN
										B.PROVISAO_ANT
									WHEN ((A.PROVISAO_DIF >= 0 AND B.PROVISAO_DIF >= 0) OR (A.PROVISAO_DIF <= 0 AND B.PROVISAO_DIF <= 0)) AND ABS(A.PROVISAO_DIF)<ABS(B.PROVISAO_DIF) AND ABS(A.PROVISAO_DIF - B.PROVISAO_DIF)>ABS(B.PROVISAO) THEN
										B.PROVISAO_ANT + (A.PROVISAO_DIF - B.PROVISAO_DIF + B.PROVISAO)
									WHEN ((A.PROVISAO_DIF >= 0 AND B.PROVISAO_DIF >= 0) OR (A.PROVISAO_DIF <= 0 AND B.PROVISAO_DIF <= 0)) AND ABS(A.PROVISAO_DIF)<ABS(B.PROVISAO_DIF) AND NOT ABS(A.PROVISAO_DIF - B.PROVISAO_DIF)>ABS(B.PROVISAO) THEN
										B.PROVISAO_ANT
									ELSE
										0.0	--NAO ENTRA EM NENHUMA ALTERNATIVA
								END
						END
		FROM
			#TMP_CALC_PROVISAO	A
		JOIN	#TMP_CALC_PROVISAO	B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		AND	B.RFS_DATA = DATEADD(DAY, -1, A.RFS_DATA)
		WHERE
			A.IC_CALCULADO = 'N'
		AND	B.IC_CALCULADO = 'S'
		AND A.RF_CARACTERISTICA = @CARAC

		-- ATUALIZA A PROVISAO E O FLAG PARA UTILIZA-LO COMO REFERENCIA NO PROXIMO UPDATE

		UPDATE	A
		SET	IC_CALCULADO	=	'S',
			PROVISAO	=	CASE
							WHEN A.EH_FUNDO = 'S' THEN
								(A.QTDE_SALDO * A.RFS_PU_MERCADO) - ((A.QTDE_SALDO * A.RFS_PU_UTEIS) + A.PROVISAO_ANT)
							ELSE
								(A.QTDE_SALDO * A.RFS_PU_MERCADO) - ((A.QTDE_SALDO * A.RFS_PU_CORRIDOS) + A.PROVISAO_ANT)
						END
		FROM
			#TMP_CALC_PROVISAO	A
		JOIN	#TMP_CALC_PROVISAO	B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		AND	B.RFS_DATA = DATEADD(DAY, -1, A.RFS_DATA)
		WHERE
			A.IC_CALCULADO = 'N'
		AND	B.IC_CALCULADO = 'S'
		AND 	A.RF_CARACTERISTICA = @CARAC

		IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
		BEGIN
			-- PROCESSO CANCELADO NA VALORIZACAO BATCH
			RETURN
		END

		SELECT @CARAC = MIN(RF_CARACTERISTICA) FROM #TMP_CALC_PROVISAO WHERE RF_CARACTERISTICA > @CARAC



	END


	-- ATUALIZA OS DADOS NA TEMPORARIA ORIGINAL

	UPDATE	A
	SET	RFS_PROVISAO_ANT	=	B.PROVISAO_ANT,
		RFS_PROVISAO_DIF	=	B.PROVISAO_DIF,
		RFS_PROVISAO		=	B.PROVISAO
	FROM
		#OPRC_LOTE A
	JOIN	#TMP_CALC_PROVISAO B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFS_DATA


	-- BUSCA TRANSFERENCIAS PARA RECALCULAR PROVISAO (NAO FUNDOS)

	INSERT INTO #TMP_TRANSF_VENDA
	EXEC('
		SELECT	A.RF_CARACTERISTICA, A.RFS_DATA,
			(SELECT	ISNULL(SUM(RFM_QTDE),0)
			FROM	RF_MOVIMENTACAO
			WHERE	RF_CARACTERISTICA = A.RF_CARACTERISTICA
			AND	RFM_DATA = A.RFS_DATA
			AND	RFM_OK = ''S''
			AND	RFM_QTDE > 0
			AND	RFM_DT = ''C''
			AND	ISNULL(IC_CLFC_ESTQ,''N'') = ''S'' /* TRANSFERENCIA DE ESTOQUE */
			) AS QTDE_V
		FROM
			#OPRC_LOTE A
		JOIN	#OPERACOES_GERAL B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE
			B.TIPO_ESTOQUE	=	''09''
		AND	B.EH_FUNDO	=	''N''
	')



INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1141'

	-- ATUALIZA PROVISAO E PROVISAO_DIF DE REGISTROS QUE TENHAM TRANSFERENCIA DE ESTOQUE

	UPDATE	B
	SET	RFS_PROVISAO	=	((B.RFS_QTDE + B.RFS_QTDE_C + A.QTDE_V) * RFS_PU_MERCADO) - ((B.RFS_QTDE + B.RFS_QTDE_C + A.QTDE_V) * RFS_PU_CORRIDOS),
		RFS_PROVISAO_DIF=	((B.RFS_QTDE + B.RFS_QTDE_C + A.QTDE_V) * RFS_PU_MERCADO) - ((B.RFS_QTDE + B.RFS_QTDE_C + A.QTDE_V) * RFS_PU_CORRIDOS)
	FROM
		#TMP_TRANSF_VENDA A
	JOIN	#OPRC_LOTE B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFS_DATA
	WHERE
		A.QTDE_V <> 0.0



	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END



	-- ***************INICIO DO CALCULO DOS FATORES ACUMULADOS*****************

	-- INSERE NA TEMPORARIA OS CAMPOS NECESSARIOS PARA OS CALCULOS (MELHOR DESEMPENHO, COMPARADO AO CALCULO NA TEMPORARIA ORIGINAL)

	INSERT INTO #TMP_CALC_FATOR_ACUD
	SELECT RF_CARACTERISTICA, RFS_DATA, RFS_DATA_ANTERIOR, RFS_PU_UTEIS, PU_U_ANTERIOR, RFS_PU_MERCADO, RFS_PU_MERCADO_ANT, V_FATR_ACUD_UTES_ANT, V_FATR_ACUD_MERC_ANT, V_FATR_ACUD_UTES, V_FATR_ACUD_MERC, 'N', PU_PARTIDA
	FROM
		#OPRC_LOTE


	-- INDICES PARA MELHORAR DESEMPENHO NOS CRUZAMENTOS

	CREATE INDEX IDX_CARAC_DATA_CALC ON #TMP_CALC_FATOR_ACUD (RF_CARACTERISTICA, RFS_DATA, IC_CALCULADO)
	CREATE INDEX IDX_CALC ON #TMP_CALC_FATOR_ACUD (IC_CALCULADO)


	-- ATUALIZA FATORES DA PRIMEIRA DATA DE TODAS AS OPERACOES

INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1190'


	UPDATE	A
	SET	IC_CALCULADO	=	'S',
		V_FATR_ACUD_UTES=	CASE
						WHEN A.RFS_DATA_ANTERIOR = '1900-01-01' THEN
							1.0
						ELSE
							V_FATR_ACUD_UTES_ANT * (PU_UTEIS / PU_UTEIS_ANTERIOR)
					END,
		V_FATR_ACUD_MERC=	CASE
						WHEN PU_PARTIDA = 0 THEN
							1.0
						WHEN A.RFS_DATA_ANTERIOR = '1900-01-01' AND PU_PARTIDA <> 0 THEN
							--1.0
							(PU_MERC / PU_PARTIDA)
						ELSE
							V_FATR_ACUD_MERC_ANT * (PU_MERC / PU_MERC_ANTERIOR)
					END
	FROM
		#TMP_CALC_FATOR_ACUD	A
	JOIN	#TMP_DATA_MINIMA	B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.DT_MINIMA


INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1223'


	-- FICA NO LOOP ATE QUE NAO HAJA MAIS REGISTROS A SEREM ATUALIZADOS, NA PRATICA, ELE RODA A QUANTIDADE DE DIAS DO PERIODO MENOS UM, POIS O PRIMEIRO DIA FOI CALCULADO LOGO ACIMA

	WHILE EXISTS(SELECT TOP 1 IC_CALCULADO FROM #TMP_CALC_FATOR_ACUD WHERE IC_CALCULADO = 'N')
	BEGIN
		UPDATE	A
		SET	IC_CALCULADO		=	'S',
			V_FATR_ACUD_UTES	=	B.V_FATR_ACUD_UTES * (A.PU_UTEIS / A.PU_UTEIS_ANTERIOR),
			V_FATR_ACUD_MERC	=	B.V_FATR_ACUD_MERC * (A.PU_MERC / A.PU_MERC_ANTERIOR)
		FROM
			#TMP_CALC_FATOR_ACUD	A
		JOIN	#TMP_CALC_FATOR_ACUD	B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		AND	B.RFS_DATA = DATEADD(DAY, -1, A.RFS_DATA)
		WHERE
			A.IC_CALCULADO = 'N'
		AND	B.IC_CALCULADO = 'S'


		-- CASO NAO CONSIGA ATUALIZAR DEVIDO A ERROS OU NAO HOUVER REGISTROS, SAI DO LOOP
		IF @@ROWCOUNT = 0 OR @@ERROR <> 0
		BEGIN
			BREAK
		END


		IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
		BEGIN
			-- PROCESSO CANCELADO NA VALORIZACAO BATCH
			RETURN
		END

	END

INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
	  SELECT 
	    USU_DATA_HORA  = GETDATE()
	  , USU_CODIGO     = 'SQL'
	  , STRU_MODULO    = 'RF3383'
	  , SIS_CODIGO     = 'VLZ'
	  , DESC_OPER      = 'LINHA: 1265'

	-- ATUALIZA OS DADOS NA TEMPORARIA ORIGINAL

	UPDATE	A
	SET	V_FATR_ACUD_UTES	=	B.V_FATR_ACUD_UTES,
		V_FATR_ACUD_MERC	=	B.V_FATR_ACUD_MERC
	FROM
		#OPRC_LOTE A
	JOIN	#TMP_CALC_FATOR_ACUD B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFS_DATA



	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END


	-- ***************INICIO DO CALCULO IOF_RESGATE E IR*****************

	-- INSERE AS OPERACOES QUE SERAO CALCULADOS O IR E IOF_RESGATE

	INSERT INTO #TMP_IR_IOFR
	(
		RF_CARACTERISTICA	,
		RFS_DATA		,
		DT_APLICACAO		,
		QTD_DIAS		,
		IOF_FCALC		,
		IR_FCALC		,
		QTDE_SALDO		,
		PU_APLICACAO		,
		VALOR_APLICACAO		,
		PU_CURVA		,
		VALOR_CURVA		,
		IOF_ALIQUOTA		,
		CIP_TABPROG		,
		VALOR_IOF		,
		ISENTO_IR		,
		FATOR_IR_INICIAL	,
		ATV_RENDA		,
		EMPRESA			,
		VALOR_IR
	)
	EXEC ('
		SELECT
			A.RF_CARACTERISTICA,
			A.RFS_DATA,
			A.RFX_PARTIDA,
			DATEDIFF(DAY, A.RFX_PARTIDA, A.RFS_DATA),
			B.RF_FCALC_IOFR,
			B.RF_FCALC_IR,
			ABS(A.RFS_QTDE) + A.RFS_QTDE_C - A.RFS_QTDE_V,
			A.PU_PARTIDA,
			CASE
				WHEN B.FIN_TRUNCA = ''S'' THEN
					DBO.SANFS_RF_TRUNCAR(A.PU_PARTIDA * (ABS(A.RFS_QTDE) + A.RFS_QTDE_C - A.RFS_QTDE_V), 2)
				ELSE
					ROUND(A.PU_PARTIDA * (ABS(A.RFS_QTDE) + A.RFS_QTDE_C - A.RFS_QTDE_V), 2)
			END AS VALOR_APLICACAO,
			A.V_PU_CTBL,
			CASE
				WHEN B.FIN_TRUNCA = ''S'' THEN
					DBO.SANFS_RF_TRUNCAR(A.V_PU_CTBL * (ABS(A.RFS_QTDE) + A.RFS_QTDE_C - A.RFS_QTDE_V), 2)
				ELSE
					ROUND(A.V_PU_CTBL * (ABS(A.RFS_QTDE) + A.RFS_QTDE_C - A.RFS_QTDE_V), 2)
			END AS VALOR_CURVA,
			C.IOF_ALIQUOTA,
			ISNULL(C.CIP_TABPROG,''''),
			0.0 AS VALOR_IOF,
			D.ATV_ISENTO_IR AS ISENTO_IR,
			0.0 AS FATOR_IR_INICIAL,
			''X'' AS ATV_RENDA,
			B.PFPJ_APELIDO_EMPRESA,
			0.0 AS VALOR_IR
		FROM
			#OPRC_LOTE A
		JOIN	#OPERACOES_GERAL B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		JOIN	#IOF_RENDA_TRIBUTACAO C
		ON	A.RFS_DATA BETWEEN C.IOF_DATA_INI AND C.IOF_DATA_FIM
		AND	C.ATV_RENDA = ''X''
		AND	C.IOF_FLAG = ''R''
		JOIN	RF_MERCADORIA D
		ON	B.ATV_CODIGO = D.ATV_CODIGO
		WHERE
			(	B.RF_TRIB_IR = ''S''
			OR	B.RF_TRIB_IOF = ''S''
			OR	(B.RF_TRIB_IR = ''N'' AND A.RFS_DATA > ''1997-12-31'')
			)
		AND	ABS(A.RFS_QTDE) <> 0.0
	')

-- SELECT 'BICUDO IR 3'
-- SELECT A.PU_PARTIDA, A.RFS_QTDE , A.RFS_QTDE_C , A.RFS_QTDE_V, * FROM #OPRC_LOTE A

	SELECT @VDT_CORTE_IOF = CN_PARM FROM SANT515_GE_PARAMETRO WHERE CH_PARM = 'CRT_IOF'
	-- LIGIA MUTO - 24/05/2011
	-- RETORNO DE IOF PARA DETERMINADOS PRODUTOS
	SELECT @VDT_RET_CORTE_IOF = CN_PARM FROM SANT515_GE_PARAMETRO WHERE CH_PARM = 'RET_IOF'

-- SELECT 'BICUDO1', * FROM #TMP_IR_IOFR
-- SELECT * FROM #OPERACOES_GERAL
-- SELECT * FROM #OPRC_LOTE
	-- DANILO 18/06/2007: PARA CLIENTES, A CURVA UTILIZADA NO CALCULO DEVE SER SEMPRE A UTEIS
	UPDATE	A
	SET	PU_CURVA = C.RFS_PU_UTEIS,
		VALOR_CURVA =	CASE
					WHEN B.FIN_TRUNCA = 'S' THEN
						DBO.SANFS_RF_TRUNCAR(C.RFS_PU_UTEIS * (ABS(C.RFS_QTDE) + C.RFS_QTDE_C - C.RFS_QTDE_V), 2)
					ELSE
						ROUND(C.RFS_PU_UTEIS * (ABS(C.RFS_QTDE) + C.RFS_QTDE_C - C.RFS_QTDE_V), 2)
				END,
		IOF_FCALC =	CASE
-- 					WHEN ISNULL(E.IC_IOF, 'S') = 'N' OR A.RFS_DATA >= @VDT_CORTE_IOF  THEN	-- DANILO 18/06/2007: NAO CALCULA IOF PARA CLIENTES QUE ESTAO COM O FLAG MARCADO COMO 'N'
-- 						CASE WHEN B.DT_AQUISICAO < @VDT_RET_CORTE_IOF OR B.ATV_CODIGO NOT IN (SELECT ATV_CODIGO FROM SANT1982_RF_DE_PARA_PROD WHERE SGL_SIST_DTIN = 'IOF') 
-- 						THEN '000' ELSE A.IOF_FCALC END
-- 					ELSE
-- 						A.IOF_FCALC
-- 				END
					WHEN B.TIPO_ESTOQUE = '01' AND F.RF_AGENTE NOT IN (SELECT PFPJ_APELIDO FROM EMPRESA) THEN '000'
					WHEN ISNULL(E.IC_IOF, 'S') = 'N'  THEN '000' 	-- DANILO 18/06/2007: NAO CALCULA IOF PARA CLIENTES QUE ESTAO COM O FLAG MARCADO COMO 'N'
          WHEN A.RFS_DATA >= @VDT_CORTE_IOF AND B.DT_AQUISICAO < @VDT_RET_CORTE_IOF AND (SELECT ATV_PUBLICO FROM RF_MERCADORIA WHERE ATV_CODIGO = B.ATV_CODIGO) = 'N' THEN '000' 
          WHEN B.ATV_CODIGO NOT IN (SELECT ATV_CODIGO FROM SANT1982_RF_DE_PARA_PROD WHERE SGL_SIST_DTIN = 'IOF')  THEN '000'
          ELSE A.IOF_FCALC
				END

	FROM
		#TMP_IR_IOFR A
	JOIN	#OPERACOES_GERAL B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	JOIN	#OPRC_LOTE C
	ON	A.RF_CARACTERISTICA = C.RF_CARACTERISTICA
	JOIN	RENDA_FIXA F
	ON	A.RF_CARACTERISTICA = F.RF_CARACTERISTICA
	AND	A.RFS_DATA = C.RFS_DATA
	LEFT JOIN POSICAO D (nolock)
	ON	A.EMPRESA = D.POS_APELIDO
	JOIN	PF_PJ E (nolock)
	ON	A.EMPRESA = E.PFPJ_APELIDO
	WHERE
		D.POS_APELIDO IS NULL	-- SOMENTE CLIENTES


	-- LIGIA MUTO - 25/05/2011
	-- NÃO HAVERÁ COBRANÇA DE IOF PARA DEBENTURES FINAL 
 
-- 	UPDATE	A
-- 	SET	IOF_FCALC =	CASE
-- 					WHEN   B.TIPO_ESTOQUE = '00' THEN	
-- 						'000' 
-- 				END
-- 	FROM
-- 		#TMP_IR_IOFR A
-- 	JOIN	#OPERACOES_GERAL B
-- 	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
-- 	JOIN	#OPRC_LOTE C
-- 	ON	A.RF_CARACTERISTICA = C.RF_CARACTERISTICA
-- 	AND	A.RFS_DATA = C.RFS_DATA
-- 	LEFT JOIN POSICAO D (nolock)
-- 	ON	A.EMPRESA = D.POS_APELIDO
-- 	JOIN	PF_PJ E (nolock)
-- 	ON	A.EMPRESA = E.PFPJ_APELIDO
-- 	WHERE
-- 		D.POS_APELIDO IS NULL	-- SOMENTE CLIENTES
-- 		AND B.ATV_CODIGO = 'DEBENTURES'



--NAO COBRAR IR DE PAPEIS ISENTOS PARA PF
	UPDATE	A
	SET	IR_FCALC =	'000' 
	FROM
		#TMP_IR_IOFR A
	JOIN	#OPERACOES_GERAL B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	JOIN	PF_PJ C (nolock)
	ON	A.EMPRESA = C.PFPJ_APELIDO
	JOIN	TIPO_PFPJ D (nolock)
	ON	C.TP_CODIGO = D.TP_CODIGO
WHERE
	B.ATV_CODIGO	IN	('LCI', 'LCA', 'LCA FGC', 'CRI', 'CRA', 'DEBENTURES INCT') AND
	D.TP_F_J	=	'F'	

	


--SELECT 'BICUDO2', * FROM #TMP_IR_IOFR

	-- ATUALIZANDO INFORMACOES PARA CALCULO DO IOF_RESGATE

	UPDATE
		A
	SET
		IOF_ALIQUOTA	=	B.CIP_PERCENTUAL
	FROM
		#TMP_IR_IOFR		A,
		CAD_IOF_PROGRESSIVO	B
	WHERE
		A.QTD_DIAS	=	B.CIP_PRAZO	AND
		B.CIP_TABPROG	=	264


	UPDATE	A
	SET	PU_RENDIMENTO = A.PU_CURVA - A.PU_APLICACAO,
		RENDIMENTO_BRUTO = ROUND(A.VALOR_CURVA - A.VALOR_APLICACAO, 2),
		DIAS_LIMITE = (SELECT MIN(CIP_PRAZO) FROM CAD_IOF_PROGRESSIVO WHERE CIP_TABPROG = A.CIP_TABPROG AND CIP_PERCENTUAL = 0.0),
		IOF = DBO.SANFS_RF_TRUNCAR(VALOR_CURVA * (DATEDIFF(DAY, DT_APLICACAO, RFS_DATA) * (A.IOF_ALIQUOTA / 100.0)), 2)
	FROM #TMP_IR_IOFR A
	WHERE
		RFS_DATA >= DT_APLICACAO
	AND	VALOR_CURVA >= VALOR_APLICACAO
	AND	IOF_FCALC NOT IN ('000', '')


INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1492'


--SELECT 'BICUDO3', * FROM #TMP_IR_IOFR

	-- BUSCANDO ALIQUOTA DO IOF

	UPDATE	A
	SET	PERC_IOF =	(SELECT ISNULL(MAX(B.CIP_PERCENTUAL),0.0)
				FROM CAD_IOF_PROGRESSIVO B (NOLOCK)
				WHERE B.CIP_TABPROG = A.CIP_TABPROG
				AND	B.CIP_PRAZO = (SELECT MAX(CIP_PRAZO) FROM CAD_IOF_PROGRESSIVO (NOLOCK) WHERE CIP_TABPROG = A.CIP_TABPROG AND CIP_PRAZO <= A.QTD_DIAS)
				)
	FROM #TMP_IR_IOFR A
	WHERE
		RFS_DATA >= DT_APLICACAO
	AND	VALOR_CURVA >= VALOR_APLICACAO
	AND	IOF_FCALC NOT IN ('000', '')

	-- APLICANDO ALIQUOTA DO IOF NO PU_RENDIMENTO E CALCULANDO O VALOR FINANCEIRO

--SELECT 'BICUDO3.5', * FROM #TMP_IR_IOFR


	UPDATE	A
	SET	REND_PERC =	DBO.SANFS_RF_TRUNCAR(PERC_IOF * PU_RENDIMENTO * QTDE_SALDO, 2)
	FROM #TMP_IR_IOFR A
	WHERE
		RFS_DATA >= DT_APLICACAO
	AND	VALOR_CURVA >= VALOR_APLICACAO
	AND	IOF_FCALC NOT IN ('000', '')

	-- CALCULANDO O IOF_RESGATE

--SELECT 'BICUDO4', * FROM #TMP_IR_IOFR

	UPDATE	A
	SET	VALOR_IOF	=	CASE
						WHEN NOT (DIAS_LIMITE > 0 AND QTD_DIAS < DIAS_LIMITE) THEN	-- VERIFICA SE ESTA NO PERIODO DE TRIBUTACAO DO IOF
							0.0
-- 						WHEN IOF < RENDIMENTO_BRUTO THEN
-- 							IOF
						WHEN PERC_IOF <> 0.0 AND RENDIMENTO_BRUTO > REND_PERC THEN
							REND_PERC
						WHEN PERC_IOF <> 0.0 AND RENDIMENTO_BRUTO <= REND_PERC THEN
							RENDIMENTO_BRUTO
						ELSE
							0.0
					END
	FROM #TMP_IR_IOFR A
	WHERE
		RFS_DATA >= DT_APLICACAO
	AND	VALOR_CURVA >= VALOR_APLICACAO
	AND	IOF_FCALC NOT IN ('000', '')

--SELECT 'BICUDO5', VALOR_CURVA,  VALOR_APLICACAO, VALOR_IOF, * FROM #TMP_IR_IOFR


	-- ATUALIZANDO INFORMACOES PARA CALCULO DO IR

	UPDATE	A
	SET	FATOR_IR_INICIAL	=	CASE
							WHEN B.RFX_QTDE <> 0.0 THEN
								B.RFX_IR_INICIAL / B.RFX_QTDE
							ELSE
								0.0
						END,
		RENDIMENTO_TOTAL	=	VALOR_CURVA - (VALOR_APLICACAO + VALOR_IOF)
	FROM	#TMP_IR_IOFR A
	JOIN	RF_INDEXACAO B (nolock)
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA


INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1571'


	-- BUSCANDO POSICAO CORRENTISTA, CASO EXISTA

	UPDATE	A
	SET	EMPRESA = ISNULL(C.PFPJ_APELIDO, '')
	FROM
		#TMP_IR_IOFR A
	LEFT JOIN POSICAO B (nolock)
	ON	A.EMPRESA = B.POS_APELIDO
	LEFT JOIN CONTAS C (nolock)
	ON	B.CTA_CORRENTISTA = C.CTA_CORRENTISTA
	WHERE
		ISNULL(C.PFPJ_APELIDO, '') <> ''

	-- MARCA SE FOR EMPRESA ESTRANGEIRA

	UPDATE	A
	SET	ATV_RENDA	=	'E'
	FROM
		#TMP_IR_IOFR A
	JOIN	PF_PJ B (nolock)
	ON	A.EMPRESA = B.PFPJ_APELIDO
	JOIN	TIPO_PFPJ C (nolock)
	ON	B.TP_CODIGO = C.TP_CODIGO
	WHERE
		C.TP_CAP_EST = 'S'

	-- FORMA DE CALCULO NA APLICACAO

	UPDATE	A
	SET	FCALC_APLICACAO	=	C.FCALC_IR
	FROM
		#TMP_IR_IOFR A
	JOIN	PF_PJ B (nolock)
	ON	A.EMPRESA	=	B.PFPJ_APELIDO
	JOIN	TIPO_RENDA_FCALCIR C (nolock)
	ON	B.TP_CODIGO	=	C.TP_CODIGO
	AND	A.ATV_RENDA	=	C.ATV_RENDA
	AND	A.DT_APLICACAO	BETWEEN	C.TRF_DATA_INI AND C.TRF_DATA_FIM




	-- FORMA DE CALCULO NA DATA

	UPDATE	A
	SET	FCALC_POSICAO	=	C.FCALC_IR
	FROM
		#TMP_IR_IOFR A
	JOIN	PF_PJ B (nolock)
	ON	A.EMPRESA	=	B.PFPJ_APELIDO
	JOIN	TIPO_RENDA_FCALCIR C (nolock)
	ON	B.TP_CODIGO	=	C.TP_CODIGO
	AND	A.ATV_RENDA	=	C.ATV_RENDA
	AND	A.RFS_DATA	BETWEEN	C.TRF_DATA_INI AND C.TRF_DATA_FIM

	-- SE A FORMA DE CALCULO NA APLICACAO FOR IGUAL A FORMA DE CALCULO DA OPERACAO, ASSUME A FORMA DE CALCULO NA DATA

	UPDATE	A
	SET	IR_FCALC	=	FCALC_POSICAO
	FROM
		#TMP_IR_IOFR A
	WHERE
		IR_FCALC	=	FCALC_APLICACAO


	-- DANILO 18/06/2007: NAO CALCULAR IR SE A FORMA DE CALCULO NAO EXISTIR

	UPDATE	A
	SET	IR_FCALC	=	'000'
	FROM
		#TMP_IR_IOFR A
	WHERE
		IR_FCALC NOT IN ('000', '')
	AND	FCALC_POSICAO NOT IN ('001', '003')


	--BUSCANDO ALIQUOTAS E INSERINDO NA TEMPORARIA

	INSERT INTO #TMP_ALIQUOTAS
	SELECT	DISTINCT
		A.ATV_RENDA,
		A.RFS_DATA,
		A.DT_APLICACAO,
		CASE 	WHEN B.TRI_DATA_INI < A.DT_APLICACAO THEN A.DT_APLICACAO
			ELSE B.TRI_DATA_INI
		END									DT_INI,
		CASE 	WHEN B.TRI_DATA_FIM > A.RFS_DATA THEN A.RFS_DATA
			ELSE B.TRI_DATA_FIM
		END									DT_FIM,
		CONVERT(DATETIME, C.CN_PARM) AS DT_MP206,
		CASE 	WHEN B.TRI_DATA_INI >= CONVERT(DATETIME, C.CN_PARM) THEN CONVERT(FLOAT, 0)
			ELSE B.TRI_ALIQUOTA
		END									V_ALQT,
		CASE
			WHEN A.DT_APLICACAO <= CONVERT(DATETIME, D.CN_PARM) THEN
				DATEDIFF(DAY, CONVERT(DATETIME, '20040701'), A.RFS_DATA)
			ELSE
				DATEDIFF(DAY, A.DT_APLICACAO, A.RFS_DATA)
		END	AS	QTD_DIAS
	FROM
		#TMP_IR_IOFR A
	JOIN	RENDA_TRIBUTACAO B (nolock)
	ON	A.ATV_RENDA	=	B.ATV_RENDA
	AND	B.TRI_DATA_INI	<=	A.RFS_DATA
	AND	B.TRI_DATA_FIM	>=	A.DT_APLICACAO
	JOIN	SANT515_GE_PARAMETRO C (nolock)
	ON	C.CH_PARM	= 'DT VIGR206'	-- DATA VIGORACAO DA MP 206
	JOIN	SANT515_GE_PARAMETRO D (nolock)
	ON	D.CH_PARM	= 'DATA MP206'	-- DATA PUBLICACAO DA MP 206
	WHERE
		RTRIM(ISNULL(B.TXT_PZ_MDIO_CART, ''))	=	''
	AND	RTRIM(ISNULL(B.TXT_PROD_APLC, ''))	=	''
	AND	A.IR_FCALC IN ('001', '003')
	AND	A.RENDIMENTO_TOTAL > 0
	AND	A.QTD_DIAS > 0


	-- ATUALIZANDO ALIQUOTAS DE ACORDO COM O PRAZO (PARA OPERACOES APOS A MP 206)

	UPDATE	A
	SET	V_ALQT = B.TRI_ALIQUOTA
	FROM
		#TMP_ALIQUOTAS A
	JOIN	RENDA_TRIBUTACAO B (nolock)
	ON	A.ATV_RENDA	=	B.ATV_RENDA
	AND	B.TRI_DATA_INI	<=	A.DT_FIM
	AND	B.TRI_DATA_FIM	>=	A.DT_FIM
	AND	B.TRI_DATA_INI	<=	A.DT_INI
	AND	B.TRI_DATA_FIM	>=	A.DT_MP206
	WHERE
		RTRIM(ISNULL(B.TXT_PZ_MDIO_CART, ''))	=	''
	AND	RTRIM(ISNULL(B.TXT_PROD_APLC, ''))	=	''
	AND	(
			B.Q_FX_ICAL_APLC	<=	A.QTD_DIAS
		AND	B.Q_FX_FINAL_APLC	>=	A.QTD_DIAS
		)


	-- ATUALIZA DATA INICIAL DOS PERIODOS POSTERIORES AO PRIMEIRO, POIS O INICIO DE UM PERIODO SEMPRE COMECA ONDE TERMINA O PERIODO ANTERIOR

	UPDATE	#TMP_ALIQUOTAS
	SET	DT_INI = DATEADD(DAY, -1, DT_INI)
	WHERE
		DT_INI > DT_APLICACAO


	-- INDICE PARA ACELERAR CRUZAMENTOS

	CREATE INDEX IDX_ALIQ ON #TMP_ALIQUOTAS (ATV_RENDA, RFS_DATA, DT_APLICACAO)


	-- CRIANDO TEMPORARIA COM O IR CALCULADO, DE ACORDO COM A ALIQUOTA DE CADA PERIODO

	SELECT
		A.RF_CARACTERISTICA, A.RFS_DATA, B.DT_FIM, B.V_ALQT, A.RENDIMENTO_TOTAL,
		RENDIMENTO_PARCIAL = ROUND(A.RENDIMENTO_TOTAL * (CONVERT(FLOAT, DATEDIFF(DAY, B.DT_INI, B.DT_FIM)) / A.QTD_DIAS), 2),
		IR	=	DBO.SANFS_RF_TRUNCAR(ROUND(A.RENDIMENTO_TOTAL * (CONVERT(FLOAT, DATEDIFF(DAY, B.DT_INI, B.DT_FIM)) / A.QTD_DIAS), 2) * (B.V_ALQT / CONVERT(FLOAT, 100)), 2)
	INTO	#TMP_VALOR_IR
	FROM
		#TMP_IR_IOFR A
	JOIN	#TMP_ALIQUOTAS B
	ON	A.ATV_RENDA = B.ATV_RENDA
	AND	A.RFS_DATA = B.RFS_DATA
	AND	A.DT_APLICACAO = B.DT_APLICACAO
	WHERE
		A.IR_FCALC IN ('001', '003')
	AND	A.RENDIMENTO_TOTAL > 0
	AND	A.QTD_DIAS > 0



	-- INDICE PARA ACELERAR CRUZAMENTOS

	CREATE INDEX IDX_CARAC_DATA ON #TMP_VALOR_IR (RF_CARACTERISTICA, RFS_DATA)


INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1756'


	-- CALCULANDO IR DO ULTIMO PERIODO, QUE DEVE SER A DIFERENCA ENTRE O RENDIMENTO TOTAL E O RENDIMENTO_ACUMULADO

	UPDATE	A
	SET	IR	=	DBO.SANFS_RF_TRUNCAR((A.RENDIMENTO_TOTAL - ISNULL(TMP.RENDIMENTO_ACUMULADO, 0.0)) * (A.V_ALQT / CONVERT(FLOAT, 100)), 2)
	FROM
		#TMP_VALOR_IR A
	LEFT JOIN	(SELECT	RF_CARACTERISTICA, RFS_DATA, SUM(ROUND(RENDIMENTO_PARCIAL, 2)) AS RENDIMENTO_ACUMULADO
			FROM	#TMP_VALOR_IR
			WHERE	DT_FIM < RFS_DATA
			GROUP BY
				RF_CARACTERISTICA, RFS_DATA) AS TMP  -- RETORNANDO O RENDIMENTO_ACUMULADO DOS PERIODOS ANTERIORES AO ULTIMO
	ON	A.RF_CARACTERISTICA = TMP.RF_CARACTERISTICA
	AND	A.RFS_DATA = TMP.RFS_DATA
	WHERE
		A.DT_FIM = A.RFS_DATA



INSERT INTO HISTORICOS (USU_DATA_HORA, USU_CODIGO, STRU_MODULO, SIS_CODIGO, DESC_OPER)
  SELECT 
    USU_DATA_HORA  = GETDATE()
  , USU_CODIGO     = 'SQL'
  , STRU_MODULO    = 'RF3383'
  , SIS_CODIGO     = 'VLZ'
  , DESC_OPER      = 'LINHA: 1783'

	-- ATUALIZANDO VALOR FINAL DO IR

	UPDATE	A
	SET	VALOR_IR = B.IR
	FROM
		#TMP_IR_IOFR A
	JOIN	(
		SELECT	RF_CARACTERISTICA, RFS_DATA, SUM(IR) AS IR	-- AGRUPANDO OS PERIODOS COM ALIQUOTAS DIFERENTES
		FROM	#TMP_VALOR_IR
		GROUP BY
			RF_CARACTERISTICA, RFS_DATA) AS B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFS_DATA


	-- ATUALIZANDO IOF_RESGATE E O IR

	UPDATE	B
	SET	RFS_IOFR = A.VALOR_IOF,
		RFS_IR = VALOR_IR
	FROM
		#TMP_IR_IOFR A
	JOIN	#OPRC_LOTE B
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFS_DATA
	WHERE
		A.VALOR_IOF <> 0.0
	OR	A.VALOR_IR <> 0.0

	-- ***************INSERCAO NA RF_SALDOS*****************
	IF @GERAR_LOG_BATCH = 'S'
	BEGIN
		INSERT INTO SANT1984_RF_CONTROLE_VALORIZACAO (DT_B, SGL_T_RG, SPID, DT_H_ATC, TXT_DESC_EVE)
		VALUES (@DT_PROCESSO, 'MSG', @SPID, GETDATE(), 'Deletando Registros (LOTE)')
	END

	-- DELETANDO A PARTIR DA DATA_MINIMA DAS OPERACOES

	SELECT
		@DT_ATUAL = DATEADD(DAY, -1, MIN(DT_MINIMA))
	FROM
		#TMP_DATA_MINIMA


	-- FICA NO LOOP ATE QUE NAO EXISTA MAIS REGISTROS

	WHILE @@ROWCOUNT <> 0 OR @DT_ATUAL < @DT_FNAL
	BEGIN

		IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
		BEGIN
			-- PROCESSO CANCELADO NA VALORIZACAO BATCH
			RETURN
		END


		SELECT	@DT_ATUAL = DATEADD(DAY, 1, @DT_ATUAL)

		-- DELETE REGISTROS DA SANT1157_RF_SALDO_GERENCIAL
		DELETE	A
		FROM
			SANT1157_RF_SALDO_GERENCIAL A (nolock)
		JOIN	#TMP_DATA_MINIMA B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE
			A.DT_SLD = @DT_ATUAL
		AND	A.DT_SLD >= B.DT_MINIMA


		-- DELETE REGISTROS DA RF_SALDOS_COTACAO
		DELETE	A
		FROM
			RF_SALDOS_COTACAO A (nolock)
		JOIN	#TMP_DATA_MINIMA B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE
			A.RFSC_DATA = @DT_ATUAL
		AND	A.RFSC_DATA >= B.DT_MINIMA


		-- DELETE REGISTROS DA RF_SALDOS
		DELETE	A
		FROM
			RF_SALDOS A (nolock)
		JOIN	#TMP_DATA_MINIMA B
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		WHERE
			A.RFS_DATA = @DT_ATUAL
		AND	A.RFS_DATA >= B.DT_MINIMA
	END

	-- INSERINDO NA RF_SALDOS
	IF @GERAR_LOG_BATCH = 'S'
	BEGIN
		SELECT @QTD_REG_INSERIR = ISNULL(COUNT(DISTINCT RF_CARACTERISTICA), 0) FROM #OPRC_LOTE

		INSERT INTO SANT1984_RF_CONTROLE_VALORIZACAO (DT_B, SGL_T_RG, SPID, DT_H_ATC, TXT_DESC_EVE)
		VALUES (@DT_PROCESSO, 'MSG', @SPID, GETDATE(), 'Gravando dados na RF_SALDOS (' + CONVERT(VARCHAR(10), @QTD_REG_INSERIR) + ' Carac.)')
	END



  -- Para as #OPRC_NAO_PADRONIZADA_SEM_FLUXO inverte JUROS x CORRECAO para manter 
  -- compatibilidade, porque a proc antiga RF0888 estava gravando  assim
  UPDATE LOTE SET
    LOTE.RFS_JUROS         = AUX.RFS_CORRECAO
  , LOTE.RFS_CORRECAO      = AUX.RFS_JUROS
  , LOTE.V_JURS_CTBL       = AUX.V_CORC_CTBL
  , LOTE.V_CORC_CTBL       = AUX.V_JURS_CTBL
  FROM #OPRC_LOTE LOTE
  JOIN (
      SELECT 
        A.RF_CARACTERISTICA
      , A.RFS_DATA
      , A.RFS_JUROS
      , A.RFS_CORRECAO
      , A.V_JURS_CTBL
      , A.V_CORC_CTBL
      FROM #OPRC_LOTE A
      JOIN #OPRC_NAO_PADRONIZADA_SEM_FLUXO B
        ON B.RF_CARACTERISTICA = A.RF_CARACTERISTICA
    ) AUX
    ON AUX.RF_CARACTERISTICA = LOTE.RF_CARACTERISTICA
    AND AUX.RFS_DATA = LOTE.RFS_DATA
  JOIN RENDA_FIXA RF
    ON RF.RF_CARACTERISTICA = LOTE.RF_CARACTERISTICA
    AND RF.IDX_CODIGO = 'CDI'



	IF EXISTS (SELECT TOP 1 CH_PARM FROM  SANT515_GE_PARAMETRO WHERE CH_PARM = 'CARACDUPL' and CN_PARM = 'S')

	BEGIN

		SELECT RF_CARACTERISTICA, RFS_DATA, COUNT(*) CONTADOR
		INTO #CARAC_DUPLICADAS
	--	, COUNT(*) 
		FROM #OPRC_LOTE
		GROUP BY 
		RF_CARACTERISTICA, RFS_DATA
		HAVING COUNT(*) > 1
	
		CREATE INDEX IDX_CARAC_DUP ON #CARAC_DUPLICADAS (RF_CARACTERISTICA, RFS_DATA)  
	
		SELECT @RF_CARACTERISTICA = MIN (RF_CARACTERISTICA) FROM #CARAC_DUPLICADAS
	
		WHILE @RF_CARACTERISTICA IS NOT NULL
	
		BEGIN
	
			SELECT @VIT_COUNT = SUM(CONTADOR) FROM #CARAC_DUPLICADAS WHERE RF_CARACTERISTICA = @RF_CARACTERISTICA 
	
			INSERT INTO HISTORICOS_VALORIZACAO (USU_DATA_HORA,USU_CODIGO,STRU_MODULO,SIS_CODIGO,DESC_OPER)  
			VALUES ( GETDATE(),'Q96','RFVEXE','RFV','CARAC DUPLICADA: ' + @RF_CARACTERISTICA + ' - COUNT(*): ' + convert(char(10),isnull(@VIT_COUNT,0)))  
	
			SELECT @RF_CARACTERISTICA = MIN (RF_CARACTERISTICA) FROM #CARAC_DUPLICADAS WHERE RF_CARACTERISTICA > @RF_CARACTERISTICA
	
		END 
	END

	INSERT INTO RF_SALDOS
	(
		RF_CARACTERISTICA	,
		RFS_DATA		,
		RFS_QTDE		,
		RFS_QTDE_C		,
		RFS_QTDE_V		,
		RFS_FIN_C		,
		RFS_FIN_V		,
		RFS_PRINCIPAL		,
		RFS_TAXA_MEDIA		,
		RFS_PU_UTEIS		,
		RFS_PU_CORRIDOS		,
		RFS_PU_CUSTO		,
		RFS_PU_MERCADO		,
		RFS_PU_MERC_ANT		,
		RFS_RESULTADO		,
		RFS_IOF			,
		RFS_IR			,
		RFS_IR_ANT		,
		RFS_JUROS		,
		RFS_JUROS_ANT		,
		RFS_CORRECAO		,
		RFS_CORRECAO_ANT	,
		LC_SITUACAO		,
		PGT_JUROS		,
		RFS_TAXA_MEDIA_U	,
		RFS_APROPRIAR		,
		RFS_APROPRIAR_ANT	,
		IR_ABERTURA		,
		PRINCIPAL_ABERTURA	,
		RFS_CORRECAO_ACRU	,
		RFS_AGDG_C		,
		RFS_AGDG_U		,
		RFS_AGDG		,
		RFS_AGDG_ANT		,
		RFS_IOFR		,
		RFS_PROVISAO_ANT	,
		RFS_PROVISAO_DIF	,
		RFS_PROVISAO		,
		RFS_PROVISAO_TRANSF	,
		V_JURS_CTBL		,
		V_CORC_CTBL		,
		V_JURS_CTBL_ANTR	,
		V_CORC_CTBL_ANTR	,
		V_FATR_ACUD_UTES	,
		V_FATR_ACUD_MERC	,
		V_PU_CTBL		,
		PDD_FXA_SEQ		,
		V_PDD			,
		V_PZ_MDIO_CALD		,
		V_PZ_MDIO_AJTD		,
		V_DURT_CALD		,
		V_PU_NEGC
	)
	SELECT
		A.RF_CARACTERISTICA		,
		A.RFS_DATA			,
		ISNULL(A.RFS_QTDE, 0)			,
		ISNULL(A.RFS_QTDE_C, 0)			,
		ISNULL(A.RFS_QTDE_V, 0)			,
		ISNULL(A.RFS_FIN_C	, 0)		,
		ISNULL(A.RFS_FIN_V, 0)			,
		ISNULL(A.RFS_PRINCIPAL, 0)			,
		ISNULL(A.RFS_TAXA_MEDIA	, 0)	,
		ISNULL(A.RFS_PU_UTEIS, 0)			,
		ISNULL(A.RFS_PU_CORRIDOS, 0)		,
		0.0				,	--RFS_PU_CUSTO
		ISNULL(A.RFS_PU_MERCADO, 0)		,
		ISNULL(A.RFS_PU_MERCADO_ANT, 0.0),
		ISNULL(A.RFS_RESULTADO, 0)			,
		ISNULL(A.RFS_IOF, 0)			,
		ISNULL(A.RFS_IR, 0)			,
		ISNULL(A.RFS_IR_ANT, 0.0)	,
		ISNULL(A.RFS_JUROS, 0)			,
		ISNULL(A.RFS_JUROS_ANT, 0)			,
		ISNULL(A.RFS_CORRECAO, 0)			,
		ISNULL(A.RFS_CORRECAO_ANT, 0.0)	,
		A.LC_SITUACAO			,
		ISNULL(A.PGT_JUROS, 0)			,
		ISNULL(A.RFS_TAXA_MEDIA_U, 0)		,
		ISNULL(A.RFS_APROPRIAR, 0)			,
		ISNULL(A.RFS_APROPRIAR_ANT, 0.0),
		ISNULL(A.IR_ABERTURA, 0)			,
		ISNULL(A.PRINCIPAL_ABERTURA, 0)		,
		0.0				,	--RFS_CORRECAO_ACRU
		ISNULL(A.RFS_AGDG_C, 0)			,
		ISNULL(A.RFS_AGDG_U, 0)			,
		ISNULL(A.RFS_AGDG, 0)			,
		ISNULL(A.RFS_AGDG_ANT, 0)			,
		ISNULL(A.RFS_IOFR, 0)			,
		ISNULL(A.RFS_PROVISAO_ANT	, 0)	,
		ISNULL(A.RFS_PROVISAO_DIF, 0)		,
		ISNULL(A.RFS_PROVISAO, 0)			,
		ISNULL(A.RFS_PROVISAO_TRANSF, 0)		,
		ISNULL(A.V_JURS_CTBL, 0)			,
		ISNULL(A.V_CORC_CTBL, 0)			,
		ISNULL(A.V_JURS_CTBL_ANTR, 0)		,
		ISNULL(A.V_CORC_CTBL_ANTR, 0)		,
		ISNULL(A.V_FATR_ACUD_UTES, 0)		,
		ISNULL(A.V_FATR_ACUD_MERC, 0)		,
		ISNULL(A.V_PU_CTBL, 0)			,
		ISNULL(A.PDD_FXA_SEQ, 0)			,
		ISNULL(A.V_PDD, 0)				,
		ISNULL(A.V_PZ_MDIO_CALD, 0)		,
		ISNULL(A.V_PZ_MDIO_AJTD, 0)		,
		ISNULL(A.V_DURT_CALD, 0)			,
		ISNULL(A.V_PU_NEGC, 0)
	FROM
		#OPRC_LOTE	A
	LEFT JOIN RF_SALDOS	B (nolock)
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFS_DATA
	WHERE
		B.RF_CARACTERISTICA IS NULL	-- NAO INSERE SE O SALDO JAH EXISTIR NA TABELA


	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END



  -- ATUALIZANDO OS VALORES "ANT" PARA AS #OPRC_NAO_PADRONIZADA_SEM_FLUXO

  UPDATE RFS SET
    RFS.RFS_IR_ANT                         = ISNULL(RFS_ANTR.RFS_IR, 0)
  , RFS.RFS_JUROS_ANT                      = ISNULL(RFS_ANTR.RFS_JUROS, 0)
  , RFS.RFS_CORRECAO_ANT                   = ISNULL(RFS_ANTR.RFS_CORRECAO, 0)
  , RFS.V_JURS_CTBL_ANTR                   = ISNULL(RFS_ANTR.V_JURS_CTBL, 0)
  , RFS.V_CORC_CTBL_ANTR                   = ISNULL(RFS_ANTR.V_CORC_CTBL, 0)
  FROM   RF_SALDOS                         RFS
  JOIN   #OPRC_LOTE                        VALZ
    ON   VALZ.RF_CARACTERISTICA            = RFS.RF_CARACTERISTICA
    AND  VALZ.RFS_DATA                     = RFS.RFS_DATA
  JOIN   #OPRC_NAO_PADRONIZADA_SEM_FLUXO   TMP
    ON   TMP.RF_CARACTERISTICA             = VALZ.RF_CARACTERISTICA
  LEFT JOIN RF_SALDOS                      RFS_ANTR
    ON   RFS_ANTR.RF_CARACTERISTICA        = RFS.RF_CARACTERISTICA
    AND  RFS_ANTR.RFS_DATA                 = (RFS.RFS_DATA -1)



	-- INSERINDO NA RF_SALDOS_COTACAO

	INSERT INTO RF_SALDOS_COTACAO
	(
		RF_CARACTERISTICA	,
		RFSC_DATA		,
		RFSC_VALOR		,
		RFSC_CENARIO		,
		SGL_MEDA		,
		RFSC_TAXA
	)
	SELECT
		A.RF_CARACTERISTICA	,
		A.RFS_DATA		,
		ISNULL(A.ULTIMA_COTACAO, 0.0),
		ISNULL(A.VALOR_CENARIO, 0.0),
		A.SGL_MEDA		,
		A.RFS_TAXA_MEDIA
	FROM
		#OPRC_LOTE	A
	LEFT JOIN RF_SALDOS_COTACAO B (nolock)
	ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
	AND	A.RFS_DATA = B.RFSC_DATA
	WHERE
		B.RF_CARACTERISTICA IS NULL	-- NAO INSERE SE O SALDO JAH EXISTIR NA TABELA



	IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
	BEGIN
		-- PROCESSO CANCELADO NA VALORIZACAO BATCH
		RETURN
	END


	-- ***************CALCULANDO PROVISAO DE TRANSFERENCIAS*****************

	-- INSERINDO MOVIMENTOS COM TRANSFERENCIA DE ESTOQUE

	INSERT INTO #TMP_PROVISAO_TRANSF
	EXEC('
		SELECT
			A.RF_CARACTERISTICA,
			A.RFS_DATA,
			A.RFS_PU_UTEIS,
			A.RFS_PU_CORRIDOS,
			A.RFS_PU_MERCADO,
			A.RFS_PROVISAO,
			A.RFS_PROVISAO_DIF
		FROM
			#OPRC_LOTE A
		JOIN	RF_MOVIMENTACAO B (nolock)
		ON	A.RF_CARACTERISTICA = B.RF_CARACTERISTICA
		AND	A.RFS_DATA = B.RFM_DATA
		JOIN	#OPERACOES_GERAL C
		ON	A.RF_CARACTERISTICA = C.RF_CARACTERISTICA
		WHERE
			C.TIPO_ESTOQUE	=	''09''
		AND	C.ATV_AP	=	''A''
		AND	B.RFM_OK	=	''S''
		AND	B.RFM_QTDE	>	0
		AND	B.CD_CATG_ORIG	>	0
		AND	ISNULL(B.IC_CLFC_ESTQ,''N'') = ''S'' /* TRANSFERENCIA DE ESTOQUE */
	')


	-- CURSOR PARA EFETUAR O CALCULO DA PROVISAO DE TRANSFERENCIA

	DECLARE curPROV_TRANSF CURSOR LOCAL READ_ONLY
	FOR
	SELECT
		RF_CARACTERISTICA,
		RFS_DATA,
		RFS_PU_UTEIS,
		RFS_PU_CORRIDOS,
		RFS_PU_MERCADO,
		RFS_PROVISAO,
		RFS_PROVISAO_DIF
	FROM
		#TMP_PROVISAO_TRANSF

	OPEN curPROV_TRANSF

	WHILE 1 = 1
	BEGIN
		FETCH NEXT FROM curPROV_TRANSF
		INTO	@RF_CARACTERISTICA,
			@RFS_DATA,
			@RFS_PU_UTEIS,
			@RFS_PU_CORRIDOS,
			@RFS_PU_MERCADO,
			@RFS_PROVISAO,
			@RFS_PROVISAO_DIF

		IF @@FETCH_STATUS <> 0
			BREAK


		-- CHAMA PROC PARA CALCULAR A PROVISAO E ATUALIZAR NA RF_MOVIMENTACAO
		EXEC SANPS_RF_PROV_TRANSF	@RF_CARACTERISTICA,
						@RFS_DATA,
						@RFS_PU_UTEIS,
						@RFS_PU_CORRIDOS,
						@RFS_PU_MERCADO,
						@RFS_PROVISAO,
						@RFS_PROVISAO_DIF,
						0.0


		IF @GERAR_LOG_BATCH = 'S' AND EXISTS(SELECT SGL_T_RG FROM SANT1984_RF_CONTROLE_VALORIZACAO WITH(NOLOCK) WHERE DT_B = @DT_PROCESSO AND SGL_T_RG = 'CANCELAR' AND SPID = @SPID)
		BEGIN
			-- PROCESSO CANCELADO NA VALORIZACAO BATCH
			RETURN
		END

	END

	CLOSE curPROV_TRANSF
	DEALLOCATE curPROV_TRANSF



	DROP TABLE #TMP_DATA_MINIMA
	DROP TABLE #TMP_CALC_PROVISAO
	DROP TABLE #TMP_CALC_FATOR_ACUD
	DROP TABLE #TMP_IR_IOFR
	DROP TABLE #TMP_ALIQUOTAS
	DROP TABLE #TMP_PROVISAO_TRANSF
END

